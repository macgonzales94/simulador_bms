"""
Manejador Modbus V2 con Servidor TCP Real
========================================

Versi√≥n actualizada que integra el servidor TCP real con el sistema existente.

Autor: Sistema BMS Demo
Versi√≥n: 2.0.0 - Con servidor TCP real
"""

import threading
import time
from typing import Dict, Any, List, Optional, Callable
from datetime import datetime, timedelta
from enum import Enum

# Importar componentes actualizados
from protocolos.modbus.cliente_modbus import ClienteModbus
from protocolos.modbus.servidor_modbus_tcp_real import ServidorModbusTCPReal
from protocolos.protocolo_base import ResultadoOperacion, EstadoProtocolo, EventoProtocolo
from configuracion.configuracion_protocolos import obtener_config_modbus
from utilidades.logger import obtener_logger_protocolo

class ModoOperacionModbus(Enum):
    """Modos de operaci√≥n del manejador Modbus."""
    SOLO_CLIENTE = "solo_cliente"
    SOLO_SERVIDOR = "solo_servidor"
    CLIENTE_SERVIDOR = "cliente_servidor"
    SOLO_SERVIDOR_TCP = "solo_servidor_tcp"  # Nuevo modo con servidor TCP real
    DESHABILITADO = "deshabilitado"

class EstadisticasModbusV2:
    """Estad√≠sticas mejoradas para el manejador Modbus V2."""
    
    def __init__(self):
        """Inicializar estad√≠sticas."""
        self.reset()
        
    def reset(self):
        """Resetear todas las estad√≠sticas."""
        self.inicio_operacion = datetime.now()
        self.operaciones_exitosas = 0
        self.operaciones_fallidas = 0
        self.reconexiones = 0
        self.comandos_recibidos = 0
        self.dispositivos_monitoreados = set()
        self.ultima_actualizacion = None
        self.errores_por_tipo = {}
        
    def obtener_resumen(self) -> Dict[str, Any]:
        """Obtener resumen de estad√≠sticas."""
        tiempo_operacion = datetime.now() - self.inicio_operacion
        total_operaciones = self.operaciones_exitosas + self.operaciones_fallidas
        
        tasa_exito = 0
        if total_operaciones > 0:
            tasa_exito = (self.operaciones_exitosas / total_operaciones) * 100
            
        return {
            'tiempo_operacion': str(tiempo_operacion),
            'total_operaciones': total_operaciones,
            'tasa_exito': round(tasa_exito, 2),
            'operaciones_exitosas': self.operaciones_exitosas,
            'operaciones_fallidas': self.operaciones_fallidas,
            'reconexiones': self.reconexiones,
            'comandos_recibidos': self.comandos_recibidos,
            'dispositivos_monitoreados': len(self.dispositivos_monitoreados),
            'ultima_actualizacion': str(self.ultima_actualizacion) if self.ultima_actualizacion else None,
            'errores_por_tipo': self.errores_por_tipo
        }

class ManejadorModbusV2:
    """
    Manejador Modbus V2 que integra servidor TCP real con el sistema existente.
    """
    
    def __init__(self, modo_operacion: ModoOperacionModbus = ModoOperacionModbus.SOLO_SERVIDOR_TCP):
        """
        Inicializar manejador Modbus V2.
        
        Args:
            modo_operacion: Modo de operaci√≥n del manejador
        """
        self.modo_operacion = modo_operacion
        self.config_modbus = obtener_config_modbus()
        self.logger = obtener_logger_protocolo("modbus")
        
        # Componentes
        self.cliente = None
        self.servidor_tcp = None  # Servidor TCP real
        
        # Control de hilos
        self.hilo_polling = None
        self.hilo_actualizador_datos = None
        self.detener_hilos = threading.Event()
        self.activo = False
        
        # Estad√≠sticas
        self.estadisticas = EstadisticasModbusV2()
        
        # Callbacks
        self.callbacks_datos_recibidos = []
        self.callbacks_estado_cambiado = []
        self.callbacks_comando_recibido = []
        
        # Cache de datos del sistema BMS
        self.datos_sistema = {
            'temperatura_lab': 25.0,
            'humedad_lab': 55.0,
            'presion_lab': 1013.2,
            'camaras_total': 1,
            'camaras_online': 1,
            'controladores_total': 1,
            'controladores_online': 1,
            'ups_total': 1,
            'ups_online': 1,
            'alarmas_activas': 0,
            'eventos_dia': 0,
            'calidad_aire': 85,
            'luminosidad': 60,
            'ruido_db': 42
        }
        
        self._inicializar_componentes()
        
    def _inicializar_componentes(self):
        """Inicializar componentes seg√∫n el modo de operaci√≥n."""
        try:
            if self.modo_operacion in [ModoOperacionModbus.SOLO_CLIENTE, ModoOperacionModbus.CLIENTE_SERVIDOR]:
                self.cliente = ClienteModbus()
                self.logger.info("üîå Cliente Modbus inicializado")
                
            if self.modo_operacion in [
                ModoOperacionModbus.SOLO_SERVIDOR_TCP, 
                ModoOperacionModbus.CLIENTE_SERVIDOR
            ]:
                # Usar servidor TCP real
                self.servidor_tcp = ServidorModbusTCPReal()
                self._configurar_callbacks_servidor_tcp()
                self.logger.info("üöÄ Servidor Modbus TCP real inicializado")
                
        except Exception as e:
            self.logger.error(f"‚ùå Error inicializando componentes Modbus: {e}")
            raise
            
    def _configurar_callbacks_servidor_tcp(self):
        """Configurar callbacks del servidor TCP real."""
        if self.servidor_tcp:
            # Callbacks para comandos espec√≠ficos
            self.servidor_tcp.agregar_callback_escritura(0, self._callback_comando_sistema)
            self.servidor_tcp.agregar_callback_escritura(1, self._callback_nivel_log)
            self.servidor_tcp.agregar_callback_escritura(2, self._callback_intervalo_polling)
            self.servidor_tcp.agregar_callback_escritura(20, self._callback_actualizar_camaras)
            self.servidor_tcp.agregar_callback_escritura(21, self._callback_actualizar_controladores)
            self.servidor_tcp.agregar_callback_escritura(22, self._callback_reiniciar_genetec)
            
    def iniciar(self) -> ResultadoOperacion:
        """Iniciar el manejador Modbus V2."""
        try:
            self.logger.info(f"üöÄ Iniciando manejador Modbus V2 en modo: {self.modo_operacion.value}")
            
            resultados = []
            
            # Iniciar cliente si est√° configurado
            if self.cliente:
                resultado_cliente = self.cliente.conectar()
                resultados.append(f"Cliente: {resultado_cliente.mensaje}")
                if resultado_cliente.exitoso:
                    self.estadisticas.dispositivos_monitoreados.add("genetec_servidor")
                    self.logger.info("‚úÖ Cliente conectado a Genetec")
                else:
                    self.logger.warning(f"‚ö†Ô∏è Cliente no pudo conectar: {resultado_cliente.mensaje}")
                    
            # Iniciar servidor TCP real si est√° configurado
            if self.servidor_tcp:
                resultado_servidor = self.servidor_tcp.conectar()
                resultados.append(f"Servidor TCP: {resultado_servidor.mensaje}")
                if not resultado_servidor.exitoso:
                    self.logger.error(f"‚ùå Servidor TCP no pudo iniciar: {resultado_servidor.mensaje}")
                    return resultado_servidor
                else:
                    self.logger.info(f"‚úÖ Servidor TCP iniciado en {self.config_modbus.ip}:{self.config_modbus.puerto}")
                    
            # Iniciar hilos de trabajo
            self.activo = True
            self.detener_hilos.clear()
            
            if self.cliente:
                self._iniciar_polling_datos()
                
            if self.servidor_tcp:
                self._iniciar_actualizador_datos_tcp()
                
            self.logger.info("‚úÖ Manejador Modbus V2 iniciado exitosamente")
            
            return ResultadoOperacion(
                exitoso=True,
                mensaje=f"Manejador Modbus V2 iniciado: {'; '.join(resultados)}",
                datos={'modo': self.modo_operacion.value}
            )
            
        except Exception as e:
            self.logger.error(f"‚ùå Error iniciando manejador Modbus V2: {e}")
            return ResultadoOperacion(
                exitoso=False,
                mensaje=f"Error iniciando manejador: {str(e)}"
            )
            
    def _iniciar_polling_datos(self):
        """Iniciar hilo de polling de datos desde cliente (Genetec)."""
        if self.cliente:
            self.hilo_polling = threading.Thread(
                target=self._bucle_polling_datos,
                name="ModbusPollingV2",
                daemon=True
            )
            self.hilo_polling.start()
            self.logger.info("üîÑ Polling de datos desde Genetec iniciado")
            
    def _iniciar_actualizador_datos_tcp(self):
        """Iniciar hilo de actualizaci√≥n de datos del servidor TCP."""
        if self.servidor_tcp:
            self.hilo_actualizador_datos = threading.Thread(
                target=self._bucle_actualizador_datos_tcp,
                name="ModbusTCPUpdater",
                daemon=True
            )
            self.hilo_actualizador_datos.start()
            self.logger.info("üìä Actualizador de datos TCP iniciado")
            
    def _bucle_polling_datos(self):
        """Bucle de polling de datos desde Genetec."""
        while self.activo and not self.detener_hilos.is_set():
            try:
                if self.cliente and self.cliente.verificar_conexion():
                    # Leer datos del sistema desde Genetec
                    resultado = self.cliente.leer_estado_sistema_bms()
                    
                    if resultado.exitoso:
                        self.estadisticas.operaciones_exitosas += 1
                        self._procesar_datos_genetec(resultado.datos)
                        self.logger.debug("üì° Datos recibidos de Genetec")
                    else:
                        self.estadisticas.operaciones_fallidas += 1
                        self.logger.warning(f"‚ö†Ô∏è Error en polling Genetec: {resultado.mensaje}")
                        
                else:
                    # Intentar reconectar
                    if self.cliente:
                        self.logger.info("üîÑ Intentando reconectar a Genetec...")
                        resultado = self.cliente.conectar()
                        if resultado.exitoso:
                            self.estadisticas.reconexiones += 1
                            self.logger.info("‚úÖ Reconectado a Genetec")
                            
            except Exception as e:
                self.logger.error(f"‚ùå Error en polling Genetec: {e}")
                self.estadisticas.errores_por_tipo['polling_genetec'] = self.estadisticas.errores_por_tipo.get('polling_genetec', 0) + 1
                
            self.detener_hilos.wait(5)  # Polling cada 5 segundos
            
    def _bucle_actualizador_datos_tcp(self):
        """Bucle que actualiza datos en el servidor TCP con informaci√≥n real del sistema."""
        while self.activo and not self.detener_hilos.is_set():
            try:
                if self.servidor_tcp and self.servidor_tcp.verificar_conexion():
                    # Actualizar datos del sistema en el servidor TCP
                    self._actualizar_datos_servidor_tcp()
                    self.estadisticas.ultima_actualizacion = datetime.now()
                    
            except Exception as e:
                self.logger.error(f"‚ùå Error actualizando servidor TCP: {e}")
                self.estadisticas.errores_por_tipo['actualizacion_tcp'] = self.estadisticas.errores_por_tipo.get('actualizacion_tcp', 0) + 1
                
            self.detener_hilos.wait(2)  # Actualizar cada 2 segundos
            
    def _procesar_datos_genetec(self, datos: Dict[str, Any]):
        """Procesar datos recibidos de Genetec y actualizar cache local."""
        try:
            # Actualizar cache local con datos reales de Genetec
            if 'temperatura' in datos:
                self.datos_sistema['temperatura_lab'] = datos['temperatura']
            if 'camaras_online' in datos:
                self.datos_sistema['camaras_online'] = datos['camaras_online']
            if 'controladores_online' in datos:
                self.datos_sistema['controladores_online'] = datos['controladores_online']
            if 'alarmas_activas' in datos:
                self.datos_sistema['alarmas_activas'] = datos['alarmas_activas']
                
            # Notificar callbacks
            for callback in self.callbacks_datos_recibidos:
                try:
                    callback(datos)
                except Exception as e:
                    self.logger.error(f"‚ùå Error en callback datos: {e}")
                    
        except Exception as e:
            self.logger.error(f"‚ùå Error procesando datos Genetec: {e}")
            
    def _actualizar_datos_servidor_tcp(self):
        """Actualizar datos en el servidor TCP con informaci√≥n real del sistema."""
        try:
            # Temperatura (x10 para decimales en Modbus)
            temp_x10 = int(self.datos_sistema['temperatura_lab'] * 10)
            self.servidor_tcp.actualizar_dato_sistema('temperatura_promedio', temp_x10)
            
            # Humedad
            humedad = int(self.datos_sistema['humedad_lab'])
            self.servidor_tcp.actualizar_dato_sistema('humedad_promedio', humedad)
            
            # Estados de dispositivos
            self.servidor_tcp.actualizar_dato_sistema('camaras_online', self.datos_sistema['camaras_online'])
            self.servidor_tcp.actualizar_dato_sistema('controladores_online', self.datos_sistema['controladores_online'])
            
            # Estado general del sistema (basado en alarmas)
            estado_general = 1 if self.datos_sistema['alarmas_activas'] == 0 else 2
            self.servidor_tcp.actualizar_dato_sistema('estado_general_sistema', estado_general)
            
            # N√∫mero de dispositivos
            dispositivos_total = len(self.estadisticas.dispositivos_monitoreados)
            self.servidor_tcp.actualizar_dato_sistema('numero_dispositivos_total', dispositivos_total)
            self.servidor_tcp.actualizar_dato_sistema('numero_dispositivos_online', dispositivos_total)
            
            # Alarmas activas
            self.servidor_tcp.actualizar_dato_sistema('numero_alarmas_activas', self.datos_sistema['alarmas_activas'])
            
            # Estado comunicaci√≥n con Genetec
            estado_genetec = 1 if (self.cliente and self.cliente.verificar_conexion()) else 0
            self.servidor_tcp.actualizar_dato_sistema('estado_comunicacion_genetec', estado_genetec)
            
            # Simular peque√±as variaciones en otros sensores para hacer m√°s realista
            import random
            
            # Presi√≥n atmosf√©rica (x10)
            presion_x10 = int(self.datos_sistema['presion_lab'] * 10) + random.randint(-20, 20)
            self.datos_sistema['presion_lab'] = presion_x10 / 10.0
            # No actualizar en servidor (no est√° mapeado), solo localmente
            
            # Calidad de aire
            calidad_actual = self.datos_sistema['calidad_aire']
            nueva_calidad = max(60, min(95, calidad_actual + random.randint(-2, 2)))
            self.datos_sistema['calidad_aire'] = nueva_calidad
            
        except Exception as e:
            self.logger.error(f"‚ùå Error actualizando datos servidor TCP: {e}")
            
    def _callback_comando_sistema(self, direccion: int, valor: int):
        """Callback para comandos del sistema."""
        self.logger.info(f"üîß COMANDO SISTEMA recibido en registro {direccion}: {valor}")
        
        self.estadisticas.comandos_recibidos += 1
        
        comando_info = {
            'direccion': direccion,
            'valor': valor,
            'timestamp': datetime.now(),
            'tipo': 'comando_sistema'
        }
        
        if valor == 1:
            self.logger.info("üîÑ Comando: RESTART sistema")
            comando_info['accion'] = 'restart'
        elif valor == 2:
            self.logger.info("‚èπÔ∏è Comando: STOP sistema")
            comando_info['accion'] = 'stop'
            # Implementar l√≥gica de parada si es necesario
        elif valor == 3:
            self.logger.info("üîÑ Comando: RESET estad√≠sticas")
            comando_info['accion'] = 'reset'
            self.estadisticas.reset()
            
        # Notificar callbacks
        for callback in self.callbacks_comando_recibido:
            try:
                callback(comando_info)
            except Exception as e:
                self.logger.error(f"‚ùå Error en callback comando: {e}")
                
    def _callback_nivel_log(self, direccion: int, valor: int):
        """Callback para cambio de nivel de logging."""
        niveles = {1: 'DEBUG', 2: 'INFO', 3: 'WARNING', 4: 'ERROR'}
        if valor in niveles:
            nivel = niveles[valor]
            self.logger.info(f"üìù Cambiando nivel de log a: {nivel}")
            # Aqu√≠ podr√≠as implementar el cambio real de nivel de logging
            
    def _callback_intervalo_polling(self, direccion: int, valor: int):
        """Callback para cambio de intervalo de polling."""
        if 1 <= valor <= 300:
            self.logger.info(f"‚è±Ô∏è Intervalo de polling cambiado a: {valor} segundos")
            # Aqu√≠ podr√≠as cambiar din√°micamente el intervalo
            
    def _callback_actualizar_camaras(self, direccion: int, valor: int):
        """Callback para forzar actualizaci√≥n de c√°maras."""
        if valor == 1:
            self.logger.info("üìπ Forzando actualizaci√≥n de c√°maras...")
            # Simular actualizaci√≥n exitosa
            self.datos_sistema['camaras_online'] = self.datos_sistema['camaras_total']
            
    def _callback_actualizar_controladores(self, direccion: int, valor: int):
        """Callback para forzar actualizaci√≥n de controladores."""
        if valor == 1:
            self.logger.info("üö™ Forzando actualizaci√≥n de controladores...")
            # Simular actualizaci√≥n exitosa
            self.datos_sistema['controladores_online'] = self.datos_sistema['controladores_total']
            
    def _callback_reiniciar_genetec(self, direccion: int, valor: int):
        """Callback para reiniciar comunicaci√≥n con Genetec."""
        if valor == 1:
            self.logger.info("üîÑ Reiniciando comunicaci√≥n con Genetec...")
            if self.cliente:
                resultado = self.cliente.reiniciar()
                if resultado.exitoso:
                    self.logger.info("‚úÖ Comunicaci√≥n con Genetec reiniciada")
                else:
                    self.logger.error(f"‚ùå Error reiniciando Genetec: {resultado.mensaje}")
                    
    def detener(self) -> ResultadoOperacion:
        """Detener el manejador Modbus V2."""
        try:
            self.logger.info("‚èπÔ∏è Deteniendo manejador Modbus V2...")
            
            self.activo = False
            self.detener_hilos.set()
            
            # Detener hilos
            if self.hilo_polling and self.hilo_polling.is_alive():
                self.hilo_polling.join(timeout=5)
                
            if self.hilo_actualizador_datos and self.hilo_actualizador_datos.is_alive():
                self.hilo_actualizador_datos.join(timeout=5)
                
            # Detener componentes
            resultados = []
            
            if self.cliente:
                resultado_cliente = self.cliente.desconectar()
                resultados.append(f"Cliente: {resultado_cliente.mensaje}")
                
            if self.servidor_tcp:
                resultado_servidor = self.servidor_tcp.desconectar()
                resultados.append(f"Servidor TCP: {resultado_servidor.mensaje}")
                
            self.logger.info("‚úÖ Manejador Modbus V2 detenido")
            
            return ResultadoOperacion(
                exitoso=True,
                mensaje=f"Manejador detenido: {'; '.join(resultados)}"
            )
            
        except Exception as e:
            self.logger.error(f"‚ùå Error deteniendo manejador: {e}")
            return ResultadoOperacion(
                exitoso=False,
                mensaje=f"Error deteniendo manejador: {str(e)}"
            )
            
    def obtener_estado_completo(self) -> Dict[str, Any]:
        """Obtener estado completo del manejador."""
        tiempo_funcionamiento = datetime.now() - self.estadisticas.inicio_operacion
        
        estado = {
            'modo_operacion': self.modo_operacion.value,
            'activo': self.activo,
            'tiempo_funcionamiento': str(tiempo_funcionamiento),
            'estadisticas': self.estadisticas.obtener_resumen(),
            'datos_sistema': self.datos_sistema.copy(),
            'configuracion': {
                'ip': self.config_modbus.ip,
                'puerto': self.config_modbus.puerto,
                'timeout': self.config_modbus.timeout
            }
        }
        
        if self.cliente:
            estado['cliente'] = {
                'conectado': self.cliente.verificar_conexion(),
                'estado': self.cliente.estado.value
            }
            
        if self.servidor_tcp:
            estado['servidor_tcp'] = {
                'activo': self.servidor_tcp.verificar_conexion(),
                'estado': self.servidor_tcp.estado.value,
                'ip': self.config_modbus.ip,
                'puerto': self.config_modbus.puerto,
                'escuchando': self.servidor_tcp.servidor_activo
            }
            
        return estado
        
    def agregar_callback_datos(self, callback: Callable[[Dict[str, Any]], None]):
        """Agregar callback para datos recibidos."""
        self.callbacks_datos_recibidos.append(callback)
        
    def agregar_callback_comando(self, callback: Callable[[Dict[str, Any]], None]):
        """Agregar callback para comandos recibidos."""
        self.callbacks_comando_recibido.append(callback)
        
    def simular_evento_sistema(self, tipo_evento: str, datos: Dict[str, Any] = None):
        """Simular eventos del sistema para pruebas."""
        try:
            if tipo_evento == "alarma_temperatura":
                self.datos_sistema['alarmas_activas'] += 1
                self.datos_sistema['temperatura_lab'] = datos.get('temperatura', 35.0)
                self.logger.warning(f"üö® Alarma de temperatura: {self.datos_sistema['temperatura_lab']}¬∞C")
                
            elif tipo_evento == "dispositivo_offline":
                dispositivo = datos.get('dispositivo', 'camara')
                if dispositivo == 'camara':
                    self.datos_sistema['camaras_online'] = max(0, self.datos_sistema['camaras_online'] - 1)
                elif dispositivo == 'controlador':
                    self.datos_sistema['controladores_online'] = max(0, self.datos_sistema['controladores_online'] - 1)
                self.logger.warning(f"üì¥ Dispositivo offline: {dispositivo}")
                
            elif tipo_evento == "reset_alarmas":
                self.datos_sistema['alarmas_activas'] = 0
                self.logger.info("‚úÖ Alarmas reseteadas")
                
        except Exception as e:
            self.logger.error(f"‚ùå Error simulando evento: {e}")

# Funci√≥n de utilidad actualizada
def crear_manejador_modbus_v2(modo: ModoOperacionModbus = ModoOperacionModbus.SOLO_SERVIDOR_TCP) -> ManejadorModbusV2:
    """Crear manejador Modbus V2 con servidor TCP real."""
    return ManejadorModbusV2(modo)

# Alias para compatibilidad con c√≥digo existente
ManejadorModbus = ManejadorModbusV2

if __name__ == "__main__":
    # Prueba del manejador V2 con servidor TCP real
    print("=== PROBANDO MANEJADOR MODBUS V2 CON SERVIDOR TCP REAL ===")
    
    try:
        manejador = crear_manejador_modbus_v2(ModoOperacionModbus.SOLO_SERVIDOR_TCP)
        
        # Iniciar manejador
        resultado = manejador.iniciar()
        print(f"‚úÖ Manejador iniciado: {resultado.mensaje}")
        
        if resultado.exitoso:
            print("üî• Servidor Modbus TCP activo - Conecta desde un cliente Modbus")
            print(f"üì° IP: {manejador.config_modbus.ip}:{manejador.config_modbus.puerto}")
            print("üìä Input Registers: 0-50 (datos del sistema)")
            print("‚öôÔ∏è Holding Registers: 0-30 (comandos)")
            print("‚èπÔ∏è Presiona Ctrl+C para detener")
            
            try:
                contador = 0
                while True:
                    time.sleep(10)
                    contador += 1
                    
                    estado = manejador.obtener_estado_completo()
                    print(f"\nüìä Ciclo {contador} - Estado del sistema:")
                    print(f"   Temperatura: {estado['datos_sistema']['temperatura_lab']:.1f}¬∞C")
                    print(f"   Dispositivos online: C:{estado['datos_sistema']['camaras_online']}/C:{estado['datos_sistema']['controladores_online']}")
                    print(f"   Comandos recibidos: {estado['estadisticas']['comandos_recibidos']}")
                    print(f"   Servidor TCP activo: {estado.get('servidor_tcp', {}).get('activo', False)}")
                    
                    # Simular eventos ocasionalmente
                    if contador % 5 == 0:
                        print("üé≠ Simulando evento de prueba...")
                        manejador.simular_evento_sistema("alarma_temperatura", {"temperatura": 32.0})
                    
            except KeyboardInterrupt:
                print("\n‚èπÔ∏è Deteniendo manejador...")
                manejador.detener()
                
    except Exception as e:
        print(f"‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        
    print("‚úÖ Prueba completada")